Usando a Linha de Comando
    - Executando Comandos
        -> Nesta aula, aprendemos a criar uma interface de linha de comando (CLI) para nossa biblioteca Node.js. O objetivo é permitir que o usuário passe o caminho de um arquivo Markdown como argumento ao executar o script, em vez de ter o caminho fixo no código.
        
        -> Principais pontos abordados:
        -> Objeto process.argv:
            * O objeto process.argv do Node.js é usado para acessar os argumentos passados na linha de comando.
            * Ele retorna um array, onde os dois primeiros elementos são o caminho para o executável do Node.js e o caminho para o script que está   sendo executado, respectivamente.
            * Os elementos subsequentes do array representam os argumentos adicionais passados pelo usuário.


        -> Criando o arquivo cli.js:
            * Um novo arquivo chamado cli.js é criado para lidar com a lógica da linha de comando.
            * Este arquivo importa a função pegaArquivo do arquivo index.js (onde a função é definida).
            * Ele acessa o caminho do arquivo Markdown fornecido pelo usuário através do process.argv e passa esse caminho para a função pegaArquivo.


        -> Exportando e Importando a função pegaArquivo:
            * A função pegaArquivo é exportada do arquivo index.js usando export default pegaArquivo;.
            * Ela é importada no arquivo cli.js usando import pegaArquivo from './index.js';.


        -> Executando o script com argumentos:
            * O script é executado a partir da linha de comando usando o comando node src/cli.js ./arquivos/texto.md, onde ./arquivos/texto.md é o caminho para o arquivo Markdown.
            * O cli.js processa este caminho e o passa para a função pegaArquivo, que então lê e processa o arquivo.



        ->Em resumo, a aula ensina como criar uma CLI simples para receber um caminho de arquivo como entrada e passá-lo para uma função em nossa biblioteca, tornando-a mais flexível e reutilizável.

    - Organizando entradas e saídas
        -> Nesta aula, o foco é aprimorar a organização e a exibição dos resultados da linha de comando (CLI) ao interagir com arquivos.
        
        -> Inicialmente, a responsabilidade de exibir os resultados na tela é removida da função pegaArquivo, que passa a apenas retornar o resultado da extração de links. 
        
        -> A biblioteca chalk é introduzida para melhorar a identificação visual dos resultados no terminal.
        
        -> A função processaTexto é criada para receber o caminho do arquivo, chamar pegaArquivo e exibir os resultados formatados no console. 
        
        -> A aula aborda a importância de lidar com promessas (Promises) em JavaScript ao trabalhar com operações assíncronas, como a leitura de arquivos, utilizando async e await para garantir que os resultados sejam processados corretamente.
        
        -> Além disso, a aula também ensina a verificar se um arquivo contém links antes de exibi-los, retornando uma mensagem informativa caso nenhum link seja encontrado.

    - Processando Diretórios
        -> Olá! Nesta aula, aprendemos como aprimorar nossa biblioteca Node.js para que ela possa processar tanto arquivos individuais Markdown quanto diretórios contendo múltiplos arquivos Markdown.

        -> Importação do Módulo fs: Adicionamos o módulo fs do Node.js para verificar se um caminho é um arquivo ou um diretório.

        -> Função processaTexto Aprimorada: Modificamos a função processaTexto para receber um array de argumentos, permitindo que ela determine se o caminho fornecido é um arquivo ou um diretório.

        -> Tratamento de Arquivos e Diretórios: Usamos fs.lstatSync para verificar se o caminho é um arquivo (isFile()) ou um diretório (isDirectory()). Se for um arquivo, processamos normalmente. Se for um diretório, lemos todos os arquivos dentro dele com fs.promises.readdir.

        -> Leitura de Diretórios: Utilizamos fs.promises.readdir para ler o conteúdo de um diretório de forma assíncrona, garantindo que todos os arquivos sejam processados corretamente.

        -> Iteração sobre Arquivos em um Diretório: Implementamos um loop forEach para iterar sobre cada arquivo encontrado no diretório e processá-lo individualmente com a função pegaArquivo.

        -> Refatoração do Código: Removemos a responsabilidade de imprimir os resultados diretamente na função processaTexto e criamos uma função separada, imprimeLista, para essa finalidade, melhorando a organização e reutilização do código.

    - Tratando novos Erros
        -> Olá! Nesta aula, o foco foi aprimorar a experiência do usuário ao lidar com erros e identificar as listas de links geradas pela biblioteca.
        
        -> Primeiramente, foi implementado um tratamento de erros para exibir mensagens mais claras quando o usuário fornece um caminho de arquivo ou diretório inexistente.
        
        -> Em seguida, a aula abordou a identificação das listas de links, exibindo o nome do arquivo ao qual cada lista se refere. 
        
        -> Isso foi feito para facilitar o rastreamento e a compreensão das listas, especialmente quando se trabalha com diretórios contendo vários arquivos.

    - scripts
        -> Nesta aula, aprendemos como usar o arquivo "package.json" para adicionar scripts, que são listas de instruções para automatizar processos no programa. 

        -> Criamos um script chamado "cli" que executa o comando node src/cli.js com os dois primeiros argumentos passados no terminal. 

        -> Também aprendemos como passar o caminho do arquivo de forma "hard coded" no script para facilitar a execução do programa. 

        -> No final, executamos o script usando o comando npm run cli e obtivemos a lista de links do arquivo especificado.

* Nessa aula, você aprendeu:
    * A utilizar a interface de linha de comando e como aplicamos a lib process do Node.js para capturar e utilizar os dados informados no terminal em nosso código;
    * A organizar o código separando em arquivos as funções que lidam com entrada e saída de dados das funções que processam os links;
    * Como fazer estes diversos arquivos conversarem entre si através da exportação e importação de módulos com import e export;
    * Que scripts são instruções que usamos para automatizar tarefas e como escrever nossos próprios scripts, incluí-los no arquivo de configuração package.json e utilizá-los para executar comandos no terminal.